(defclass board ()
  ((deck :initarg :deck :accessor deck)
   (discard :initform nil :accessor discard)
   (detector-free :initform nil :accessor detector-free)
   (detector-conf :initform nil :accessor detector-conf)
   (background-free :initform nil :accessor background-free)
   (background-conf :initform nil :accessor background-conf)))

(defparameter *board* nil)

(defun shuffle-deck (deck)
  (if (or (null deck) (equal (length deck) 1))
      deck
      (let ((pos (random (length deck))))
        (cons (nth pos deck) (shuffle-deck (nconc (subseq deck 0 pos) (nthcdr (1+ pos) deck)))))))

(defun flip-cards (deck)
  (mapcar #'(lambda (card) (case (first card)
                             (quark (list 'quark (not (second card)) (third card) (fourth card)))))
          deck))

(defun make-deck (colors flavors)
  (let* ((cards (apply #'nconc (mapcar #'(lambda (c) (mapcar #'(lambda (f) (list 'quark nil c f)) flavors)) colors)))
         (size (* (length colors) (length flavors)))
         (anticount (+ (1- (if (oddp size) (+ (/ (1- size) 2) (random 2)) (/ size 2))) (random 3))))
    (setf cards (shuffle-deck cards))
    (setf cards (nconc (subseq cards 0 (- size anticount)) (flip-cards (nthcdr (- size anticount) cards))))
    (setf cards (shuffle-deck cards))
    cards))

(defun get-valid-answer (message validity-p-func)
  (format t message)
  (let ((answer (read-line)))
    (loop while (not (funcall validity-p-func answer))
          do (format t "That's not an applicable answer! Please try again:")
          do (setf answer (read-line)))
    answer))

(defun get-card-name (card)
  (cond ((listp (first card)) (apply #'concatenate 'string "Confinement  -" (loop for c in card collect "  " collect (get-card-name c))))
        ((eq (first card) 'quark) (format nil "~a ~a ~a" (third card) (fourth card) (if (second card) "Antiquark" "Quark")))
        ((eq (first card) 'annihilate) (format nil "Annihilate"))))

(defun print-card-list (cards)
  (loop for card in cards
        for i from 1
        do (format t "~D: ~a~%" i (get-card-name card))))

(defun print-board ()
  (format t "Quarks in Detector:~%")
  (print-card-list (append (detector-conf *board*) (detector-free *board*)))
  (format t "Quarks in Background:~%")
  (print-card-list (append (background-conf *board*) (background-free *board*)))
  (format t "Cards in Discard:~%")
  (print-card-list (discard *board*))
  (format t "Deck Top Card: ~A~%" (if (deck *board*) (get-card-name (first (deck *board*))) "Empty!")))

(defun annihilate-free ()
  (let ((ql (append (detector-free *board*) (background-free *board*))))
    (if (null ql)
        (format t "Fortunately, this annihilate card has no free quarks to target!~%")
        (progn (print-card-list ql)
               (let ((sel (parse-integer (get-valid-answer "Select a free quark to annihilate from the Detector or Background." #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                                 (and innum (> innum 0) (< innum (1+ (length ql))))))))))
                 (setf sel (1- sel))
                 (setf (detector-free *board*) (remove (nth sel ql) (detector-free *board*) :test #'equal)
                       (background-free *board*) (remove (nth sel ql) (background-free *board*) :test #'equal)))))))

(defun beam-get-card (beam name)
  (if (null (cdr beam))
      (progn (format t "The ~A automatically goes to the ~A.~%" (get-card-name (car beam)) name)
             (car beam))
      (progn (print-card-list beam)
             (let ((sel (parse-integer (get-valid-answer (format nil "Select a card from the beam to move to the ~a:~%" name) #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                               (and innum (> innum 0) (< innum (1+ (length beam))))))))))
               (setf sel (1- sel))
               (nth sel beam)))))

(defun distribute-cards (beam)
  (format t "Now you shall distribute the beam into the background, detector, and discard, in that order.~%")
  (setf beam (remove nil (mapcar #'(lambda (card) (case (first card)
                                                    (annihilate (progn (annihilate-free) nil))
                                                    (quark card)))
                                 beam)))
  (when beam
    (let ((card (beam-get-card beam "Background")))
      (setf (background-free *board*) (cons card (background-free *board*))
            beam (remove card beam :test #'equal)))
    (when beam
      (let ((card (beam-get-card beam "Detector")))
        (setf (detector-free *board*) (cons card (detector-free *board*))
              beam (remove card beam :test #'equal)))
      (when beam
        (let ((card (beam-get-card beam "Discard")))
          (setf (discard *board*) (cons card (discard *board*))))))))

(defun break-conf-detector ()
  (format t "Confinements in Detector:~%")
  (print-card-list (detector-conf *board*))
  (let ((sel (parse-integer (get-valid-answer "Select a confinement to break, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                           (and innum (> innum -1) (< innum (1+ (length (detector-conf *board*)))))))))))
    (unless (zerop sel)
      (setf (detector-conf *board*) (nconc (nth (1- sel) (detector-conf *board*))
                                           (remove (nth (1- sel) (detector-conf *board*)) (detector-conf *board*) :test #'equal)))
      (break-conf-detector))))

(defun break-conf-background ()
  (format t "Confinements in Background:~%")
  (print-card-list (background-conf *board*))
  (let ((sel (parse-integer (get-valid-answer "Select a confinement to break, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                           (and innum (> innum -1) (< innum (1+ (length (background-conf *board*)))))))))))
    (unless (zerop sel)
      (setf (background-conf *board*) (nconc (nth (1- sel) (background-conf *board*))
                                             (remove (nth (1- sel) (background-conf *board*)) (background-conf *board*) :test #'equal)))
      (break-conf-background))))

(defun check-valid-containment (quarks)
  (or (and (equal (length quarks) 2)
           (eq (third (first quarks)) (third (second quarks)))
           (not (eq (second (first quarks)) (second (second quarks)))))
      (and (equal (length quarks) 3)
           (and (eq (second (first quarks)) (second (second quarks)))
                (eq (second (second quarks)) (second (third quarks))))
           (equal (length (remove-duplicates (mapcar #'third quarks))) 3))))

(defun build-conf-detector ()
  (let ((curfree (detector-free *board*)))
    (format t "Free Quarks in Detector: ~%")
    (print-card-list curfree)
    (let ((curconf nil)
          (sel (parse-integer (get-valid-answer "Select a free quark to add to the current confinement, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                     (and innum (> innum -1) (< innum (1+ (length curfree))))))))))
      (loop while (not (zerop sel))
            do (setf curconf (cons (nth (1- sel) curfree) curconf)
                     curfree (remove (nth (1- sel) curfree) curfree :test #'equal))
            do (print-card-list curfree)
            do (setf sel (parse-integer (get-valid-answer "Select a free quark to add to the current confinement, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                               (and innum (> innum -1) (< innum (1+ (length curfree))))))))))
      (unless (null curconf)
        (if (check-valid-containment curconf)
            (setf (detector-conf *board*) (cons curconf (detector-conf *board*))
                  (detector-free *board*) curfree)
            (format t "That's not a valid confinement!~%"))
        (build-conf-detector)))))

(defun build-conf-background ()
  (let ((curfree (background-free *board*)))
    (format t "Free Quarks in Background: ~%")
    (print-card-list curfree)
    (let ((curconf nil)
          (sel (parse-integer (get-valid-answer "Select a free quark to add to the current confinement, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                     (and innum (> innum -1) (< innum (1+ (length curfree))))))))))
      (loop while (not (zerop sel))
            do (setf curconf (cons (nth (1- sel) curfree) curconf)
                     curfree (remove (nth (1- sel) curfree) curfree :test #'equal))
            do (print-card-list curfree)
            do (setf sel (parse-integer (get-valid-answer "Select a free quark to add to the current confinement, 0 to stop:" #'(lambda (in) (let ((innum (parse-integer in :junk-allowed t)))
                                                                                                                                               (and innum (> innum -1) (< innum (1+ (length curfree))))))))))
      (unless (null curconf)
        (if (check-valid-containment curconf)
            (setf (background-conf *board*) (cons curconf (background-conf *board*))
                  (background-free *board*) curfree)
            (format t "That's not a valid confinement!~%"))
        (build-conf-background)))))

(defun modify-confinement ()
  (break-conf-detector)
  (build-conf-detector)
  (break-conf-background)
  (build-conf-background))

(defun annihilate-quark-antiquark-pairs ()
  (setf (detector-free *board*)
        (remove nil
                (mapcar #'(lambda (a)
                            (if (some #'(lambda (b) (and (eq (first a) (first b))
                                                         (not (eq (second a) (second b)))
                                                         (eq (fourth a) (fourth b))))
                                      (detector-free *board*))
                                (format t "The quark ~a is annihilated!~%" (get-card-name a))
                                a)) (detector-free *board*)))
        (background-free *board*)
        (remove nil
                (mapcar #'(lambda (a)
                            (if (some #'(lambda (b) (and (eq (first a) (first b))
                                                         (not (eq (second a) (second b)))
                                                         (eq (fourth a) (fourth b))))
                                      (background-free *board*))
                                (format t "The quark ~a is annihilated!~%" (get-card-name a))
                                a)) (background-free *board*)))))

(defun game-win-check ()
  (let* ((totdet (append (apply #'append (detector-conf *board*)) (detector-free *board*)))
         (ups (remove-if-not #'(lambda (c) (and (not (second c)) (eq (fourth c) 'up))) totdet))
         (downs (remove-if-not #'(lambda (c) (and (not (second c)) (eq (fourth c) 'down))) totdet))
         (charms (remove-if-not #'(lambda (c) (and (not (second c)) (eq (fourth c) 'charm))) totdet))
         (acharms (remove-if-not #'(lambda (c) (and (second c) (eq (fourth c) 'charm))) totdet)))
    (some #'(lambda (u1)
              (some #'(lambda (u2)
                        (some #'(lambda (d)
                                  (some #'(lambda (c)
                                            (some #'(lambda (ac)
                                                      (or (and (check-valid-containment (list u1 ac)) (check-valid-containment (list u2 d c)))
                                                          (and (check-valid-containment (list u2 ac)) (check-valid-containment (list u1 d c)))
                                                          (and (check-valid-containment (list d ac)) (check-valid-containment (list u1 u2 c)))))
                                                  acharms))
                                        charms))
                              downs))
                    (remove u1 ups :test #'equal)))
          ups)))

(defun game-loss-check ()
  (let ((totcards (append (deck *board*) (discard *board*) (apply #'append (detector-conf *board*)) (detector-free *board*) (apply #'append (background-conf *board*)) (background-free *board*))))
    (or (< (length (remove-if-not #'(lambda (c) (eq (fourth c) 'up)) totcards)) 2)
        (< (length (remove-if-not #'(lambda (c) (eq (fourth c) 'charm)) totcards)) 2)
        (null (remove-if-not #'(lambda (c) (eq (fourth c) 'down)) totcards)))))

(defun refresh-phase ()
  (setf (deck *board*) (shuffle-deck (append '((annihilate)) (detector-free *board*) (apply #'append (background-conf *board*)) (discard *board*)))
        (discard *board*) nil
        (detector-free *board*) nil
        (background-conf *board*) nil
        (background-free *board*) nil))

(defun game-loop ()
  (if (deck *board*)
      (progn (let ((beam (if (cddr (deck *board*))
                             (subseq (deck *board*) 0 3)
                             (deck *board*))))
               (setf (deck *board*) (cdddr (deck *board*)))
               (print-board)
               (distribute-cards beam))
             (modify-confinement)
             (annihilate-quark-antiquark-pairs)
             (if (game-win-check)
                 (format t "Good job, you've formed a pentaquark! You win!~%")
                 (game-loop)))
      (progn (refresh-phase)
             (if (game-loss-check)
                 (format t "There's not enough quarks to form a pentaquark! You lose!~%")
                 (game-loop)))))

(defun start-game ()
  (defparameter *board* (make-instance 'board :deck (make-deck '(red green blue) '(up down bottom strange charm))))
  (game-loop))
